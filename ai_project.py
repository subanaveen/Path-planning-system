# -*- coding: utf-8 -*-
"""AI Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1majpk9EReflJpYnN4kMKurLLBKhcDQBw
"""

pip install python-constraint

from constraint import Problem
import math

# Define weights for each edge
weights = {
("Vijayawada", "Mangalagiri"): 75,
    ("Vijayawada", "Guntur"): 140,
    ("Vijayawada", "Tenali"): 118,
    ("Tenali","Guntur"): 40,
    ("Tenali","Repalle"): 75,
    ("Repalle","Machilipatnam"): 80,
    ("Repalle","Gudivada"): 55,
    ("Mangalagiri", "Nidamanuru"): 71,
    ("Mangalagiri", "Hyderabad"): 195,
    ("Nidamanuru", "Hyderabad"): 111,
    ("Nidamanuru", "Guntur"): 65,
    ("Hyderabad", "Neerukonda"): 99,
    ("Hyderabad", "Kakinada"): 167,
    ("Guntur", "Neerukonda"): 80,
    ("Guntur", "Vuyyuru"): 50,
    ("Hyderabad", "Gannavaram"): 70,
    ("Neerukonda", "Bhimavaram"): 211,
    ("Kuragallu", "Bhimavaram"): 30,
    ("Gannavaram", "Bhimavaram"): 138,
    ("Gannavaram", "Kakinada"): 138,
    ("Gannavaram", "Machilipatnam"): 75,
    ("Bhimavaram", "Tuni"): 101,
    ("Bhimavaram", "Rajahmundry"): 85,
    ("Kuragallu", "Vuyyuru"): 40,
    ("Tuni", "Kakinada"): 138,
    ("Kakinada", "Rajahmundry"): 75,
    ("Kakinada", "Godavari"): 310,
    ("Rajahmundry", "Godavari"): 200,
    ("Rajahmundry", "Eluru"): 75,
    ("Bhimavaram", "Eluru"): 70,
    ("Gudivada", "Eluru"): 20,
    ("Godavari", "Eluru"): 60,
    ("Annavaram", "Eluru"): 80,
    ("Godavari", "Annavaram"): 75
}

# Define coordinates for each city
coordinates = {
    'Vijayawada': (0, 0),
    'Mangalagiri': (75, 0),
    'Guntur': (75, 140),
    'Tenali': (0, 140),
    'Nidamanuru': (150, 70),
    'Hyderabad': (200, 0),
    'Neerukonda': (250, 70),
    'Kuragallu': (300, 140),
    'Gannavaram': (375, 70),
    'Eluru': (375, 210),
    'Machilipatnam': (300, 280),
    'Repalle': (150, 210),
    'Vuyyuru': (225, 140),
    'Gudivada': (300, 210),
    'Bhimavaram': (375, 140),
    'Tuni': (525, 140),
    'Kakinada': (525, 0),
    'Rajahmundry': (450, 70),
    'Godavari': (450, 280),
    'Annavaram': (525, 280)
}

problem = Problem()

# Define variables
cities = list(coordinates.keys())

# Add variables to the problem
for city in cities:
    problem.addVariable(city, coordinates[city])

# Define constraints based on weights
for edge, dist in weights.items():
    city1, city2 = edge

    def distance_constraint(x, y, dist=dist):
        return math.sqrt((x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2) == dist

    problem.addConstraint(distance_constraint, (city1, city2))

solutions = problem.getSolutions()
print("Number of solutions:", len(solutions))
for solution in solutions:
    print(solution)

import heapq
import math

# Define weights for each edge
weights = {
    ("Vijayawada", "Mangalagiri"): 75,
    ("Vijayawada", "Guntur"): 140,
    ("Vijayawada", "Tenali"): 118,
    ("Tenali","Guntur"): 40,
    ("Tenali","Repalle"): 75,
    ("Repalle","Machilipatnam"): 80,
    ("Repalle","Gudivada"): 55,
    ("Mangalagiri", "Nidamanuru"): 71,
    ("Mangalagiri", "Hyderabad"): 195,
    ("Nidamanuru", "Hyderabad"): 111,
    ("Nidamanuru", "Guntur"): 65,
    ("Hyderabad", "Neerukonda"): 99,
    ("Hyderabad", "Kakinada"): 167,
    ("Guntur", "Neerukonda"): 80,
    ("Guntur", "Vuyyuru"): 50,
    ("Hyderabad", "Gannavaram"): 70,
    ("Neerukonda", "Bhimavaram"): 211,
    ("Kuragallu", "Bhimavaram"): 30,
    ("Gannavaram", "Bhimavaram"): 138,
    ("Gannavaram", "Kakinada"): 138,
    ("Gannavaram", "Machilipatnam"): 75,
    ("Bhimavaram", "Tuni"): 101,
    ("Bhimavaram", "Rajahmundry"): 85,
    ("Kuragallu", "Vuyyuru"): 40,
    ("Tuni", "Kakinada"): 138,
    ("Kakinada", "Rajahmundry"): 75,
    ("Kakinada", "Godavari"): 310,
    ("Rajahmundry", "Godavari"): 200,
    ("Rajahmundry", "Eluru"): 75,
    ("Bhimavaram", "Eluru"): 70,
    ("Gudivada", "Eluru"): 20,
    ("Godavari", "Eluru"): 60,
    ("Annavaram", "Eluru"): 80,
    ("Godavari", "Annavaram"): 75
}

# Define coordinates for each city
coordinates = {
    'Vijayawada': (0, 0),
    'Mangalagiri': (75, 0),
    'Guntur': (75, 140),
    'Tenali': (0, 140),
    'Nidamanuru': (150, 70),
    'Hyderabad': (200, 0),
    'Neerukonda': (250, 70),
    'Kuragallu': (300, 140),
    'Gannavaram': (375, 70),
    'Eluru': (375, 210),
    'Machilipatnam': (300, 280),
    'Repalle': (150, 210),
    'Vuyyuru': (225, 140),
    'Gudivada': (300, 210),
    'Bhimavaram': (375, 140),
    'Tuni': (525, 140),
    'Kakinada': (525, 0),
    'Rajahmundry': (450, 70),
    'Godavari': (450, 280),
    'Annavaram': (525, 280)
}

class PriorityQueue:
    def __init__(self):
        self.cities = []

    def push(self, city, cost):
        heapq.heappush(self.cities, (cost, city))

    def pop(self):
        return heapq.heappop(self.cities)[1]

    def is_empty(self):
        return not bool(self.cities)

    def check(self):
        print(self.cities)

romania = {}

def makedict():
    for edge, dist in weights.items():
        ct1, ct2 = edge
        romania.setdefault(ct1, []).append((ct2, dist))
        romania.setdefault(ct2, []).append((ct1, dist))

def heuristic(node, values):
    return values[node]

def astar(start, end):
    path = {}
    distance = {}
    q = PriorityQueue()

    q.push(start, 0)
    distance[start] = 0
    path[start] = None
    expanded_list = []

    while not q.is_empty():
        current = q.pop()
        expanded_list.append(current)

        if current == end:
            break

        for new, dist in romania[current]:
            g_cost = distance[current] + weights.get((current, new), weights.get((new, current), 0))  # Correct order

            if new not in distance or g_cost < distance[new]:
                distance[new] = g_cost
                f_cost = g_cost + calculate_straight_line_distance(new, end)
                q.push(new, f_cost)
                path[new] = current

    print_output(start, end, path, distance, expanded_list)

new_l=[]
def print_output(start, end, path, distance, expanded_list):
    final_path = []
    i = end

    while path[i] is not None:
        final_path.append(i)
        i = path[i]
    final_path.append(start)
    final_path.reverse()
    new_l.extend(final_path)
    print("A* algorithm program for the given problem")
    print("\t{} => {}".format(start, end))
    print("=======================================================")
    print("A city that may be explored \t\t: " + str(expanded_list))
    print("Number of possible cities\t\t: " + str(len(expanded_list)))
    print("=======================================================")
    print("The city passed with the shortest distance\t: " + str(final_path))
    print("Number of cities passed \t\t\t: " + str(len(final_path)))
    print("Total distance \t\t\t\t\t: " + str(distance[end]))

def euclidean_distance(coord1, coord2):
    return math.sqrt((coord2[0] - coord1[0]) ** 2 + (coord2[1] - coord1[1]) ** 2)

def calculate_straight_line_distance(city1, city2):
    coord1 = coordinates[city1]
    coord2 = coordinates[city2]
    distance = euclidean_distance(coord1, coord2)
    return distance

# Example usage
src = "Hyderabad"
dst = "Godavari"
makedict()
astar(src, dst)

class CityPathCSP:
    def __init__(self, weights, coordinates):
        self.weights = weights
        self.coordinates = coordinates
        self.path_variables = list(coordinates.keys())

    def find_shortest_path_between_cities(self, src, dst):
        # Implement Dijkstra's algorithm to find the shortest path between two cities

        if src not in self.path_variables or dst not in self.path_variables:
            print("Invalid source or destination.")
            return []

        distances = {city: float('inf') for city in self.path_variables}
        distances[src] = 0
        previous_city = {city: None for city in self.path_variables}
        queue = [src]

        while queue:
            current_city = queue.pop(0)
            for neighbor, weight in self.weights[current_city]:
                new_distance = distances[current_city] + weight
                if new_distance < distances[neighbor]:
                    distances[neighbor] = new_distance
                    previous_city[neighbor] = current_city
                    if neighbor not in queue:
                        queue.append(neighbor)

        path = []
        current = dst
        while current:
            path.append(current)
            current = previous_city[current]

        path.reverse()
        return path

    def find_path_with_required_city(self, src, required_city, dst):
        # Find paths from source to required city and from required city to destination
        path_from_src_to_required = self.find_shortest_path_between_cities(src, required_city)
        path_from_required_to_dst = self.find_shortest_path_between_cities(required_city, dst)

        if not path_from_src_to_required or not path_from_required_to_dst:
            print("No valid path between cities with the given constraints.")
            return []

        full_path = path_from_src_to_required[:-1] + path_from_required_to_dst  # Combine both paths
        print("Shortest path found with required city:", full_path)
        return full_path
# Define weights for each edge

weights = {
    "Vijayawada": [("Mangalagiri", 75), ("Guntur", 140), ("Tenali", 118)],
    "Mangalagiri": [("Vijayawada", 75), ("Nidamanuru", 71), ("Hyderabad", 195)],
    "Guntur": [("Vijayawada", 140), ("Tenali", 40), ("Nidamanuru", 65), ("Neerukonda", 80), ("Vuyyuru", 50)],
    "Tenali": [("Vijayawada", 118), ("Guntur", 40), ("Repalle", 75)],
    "Repalle": [("Tenali", 75), ("Machilipatnam", 80), ("Gudivada", 55)],
    "Machilipatnam": [("Repalle", 80), ("Gannavaram", 75)],
    "Gudivada": [("Repalle", 55), ("Eluru", 20)],
    "Nidamanuru": [("Mangalagiri", 71), ("Hyderabad", 111), ("Guntur", 65)],
    "Hyderabad": [("Mangalagiri", 195), ("Nidamanuru", 111), ("Neerukonda", 99), ("Kakinada", 167), ("Gannavaram", 70)],
    "Neerukonda": [("Hyderabad", 99), ("Bhimavaram", 211)],
    "Kakinada": [("Hyderabad", 167), ("Rajahmundry", 75), ("Godavari", 310), ("Tuni", 138)],
    "Gannavaram": [("Hyderabad", 70), ("Bhimavaram", 138), ("Kakinada", 138), ("Machilipatnam", 75)],
    "Bhimavaram": [("Neerukonda", 211), ("Tuni", 101), ("Rajahmundry", 85), ("Eluru", 70), ("Kuragallu", 30)],
    "Tuni": [("Kakinada", 138), ("Bhimavaram", 101)],
    "Rajahmundry": [("Bhimavaram", 85), ("Kakinada", 75), ("Godavari", 200), ("Eluru", 75)],
    "Godavari": [("Kakinada", 310), ("Rajahmundry", 200), ("Eluru", 60), ("Annavaram", 75)],
    "Eluru": [("Gudivada", 20), ("Bhimavaram", 70), ("Rajahmundry", 75), ("Godavari", 60), ("Annavaram", 80)],
    "Annavaram": [("Eluru", 80), ("Godavari", 75)],
    "Kuragallu": [("Vuyyuru", 40), ("Bhimavaram", 30)],
    "Vuyyuru": [("Guntur", 50), ("Kuragallu", 40)]
    # Continue defining neighbors and weights for other cities if necessary
}

# Define coordinates for each city
coordinates = {
        'Vijayawada': (0, 0),
    'Mangalagiri': (75, 0),
    'Guntur': (75, 140),
    'Tenali': (0, 140),
    'Nidamanuru': (150, 70),
    'Hyderabad': (200, 0),
    'Neerukonda': (250, 70),
    'Kuragallu': (300, 140),
    'Gannavaram': (375, 70),
    'Eluru': (375, 210),
    'Machilipatnam': (300, 280),
    'Repalle': (150, 210),
    'Vuyyuru': (225, 140),
    'Gudivada': (300, 210),
    'Bhimavaram': (375, 140),
    'Tuni': (525, 140),
    'Kakinada': (525, 0),
    'Rajahmundry': (450, 70),
    'Godavari': (450, 280),
    'Annavaram': (525, 280)
    # ... (Your coordinates dictionary here)
}



src = "Vijayawada"
dst = "Mangalagiri"
required_city = "Guntur"
csp_solver = CityPathCSP(weights, coordinates)
csp_solver.find_path_with_required_city(src, required_city, dst)

class CityPathCSP:
    def __init__(self, weights, coordinates):
        self.weights = weights
        self.coordinates = coordinates
        self.path_variables = list(coordinates.keys())

    def find_shortest_path_between_cities(self, src, dst):
        # Implementation of Dijkstra's algorithm to find the shortest path between two cities
        if src not in self.path_variables or dst not in self.path_variables:
            print("Invalid source or destination.")
            return []

        distances = {city: float('inf') for city in self.path_variables}
        distances[src] = 0
        previous_city = {city: None for city in self.path_variables}
        queue = [src]

        while queue:
            current_city = queue.pop(0)
            for neighbor, weight in self.weights[current_city]:
                new_distance = distances[current_city] + weight
                if new_distance < distances[neighbor]:
                    distances[neighbor] = new_distance
                    previous_city[neighbor] = current_city
                    if neighbor not in queue:
                        queue.append(neighbor)

        path = []
        current = dst
        while current:
            path.append(current)
            current = previous_city[current]

        path.reverse()
        return path

    def calculate_path_cost(self, path):
        total_cost = 0
        for i in range(len(path) - 1):
            current_city = path[i]
            next_city = path[i + 1]
            for neighbor, weight in self.weights[current_city]:
                if neighbor == next_city:
                    total_cost += weight
                    break
        return total_cost

    def find_path_with_required_city(self, src, required_city, dst):
        # Finding paths from source to required city and from required city to destination
        path_from_src_to_required = self.find_shortest_path_between_cities(src, required_city)
        path_from_required_to_dst = self.find_shortest_path_between_cities(required_city, dst)

        if not path_from_src_to_required or not path_from_required_to_dst:
            print("No valid path between cities with the given constraints.")
            return [], 0  # Returning an empty path and cost in case of failure

        full_path = path_from_src_to_required[:-1] + path_from_required_to_dst  # Combining both paths
        total_cost = self.calculate_path_cost(full_path)
        print("Shortest path found with required city:", full_path)
        print("Total cost of the path:", total_cost)
        return full_path, total_cost


# Define weights for each edge
weights = {
    "Vijayawada": [("Mangalagiri", 75), ("Guntur", 140), ("Tenali", 118)],
    "Mangalagiri": [("Vijayawada", 75), ("Nidamanuru", 71), ("Hyderabad", 195)],
    "Guntur": [("Vijayawada", 140), ("Tenali", 40), ("Nidamanuru", 65), ("Neerukonda", 80), ("Vuyyuru", 50)],
    "Tenali": [("Vijayawada", 118), ("Guntur", 40), ("Repalle", 75)],
    "Repalle": [("Tenali", 75), ("Machilipatnam", 80), ("Gudivada", 55)],
    "Machilipatnam": [("Repalle", 80), ("Gannavaram", 75)],
    "Gudivada": [("Repalle", 55), ("Eluru", 20)],
    "Nidamanuru": [("Mangalagiri", 71), ("Hyderabad", 111), ("Guntur", 65)],
    "Hyderabad": [("Mangalagiri", 195), ("Nidamanuru", 111), ("Neerukonda", 99), ("Kakinada", 167), ("Gannavaram", 70)],
    "Neerukonda": [("Hyderabad", 99), ("Bhimavaram", 211)],
    "Kakinada": [("Hyderabad", 167), ("Rajahmundry", 75), ("Godavari", 310), ("Tuni", 138)],
    "Gannavaram": [("Hyderabad", 70), ("Bhimavaram", 138), ("Kakinada", 138), ("Machilipatnam", 75)],
    "Bhimavaram": [("Neerukonda", 211), ("Tuni", 101), ("Rajahmundry", 85), ("Eluru", 70), ("Kuragallu", 30)],
    "Tuni": [("Kakinada", 138), ("Bhimavaram", 101)],
    "Rajahmundry": [("Bhimavaram", 85), ("Kakinada", 75), ("Godavari", 200), ("Eluru", 75)],
    "Godavari": [("Kakinada", 310), ("Rajahmundry", 200), ("Eluru", 60), ("Annavaram", 75)],
    "Eluru": [("Gudivada", 20), ("Bhimavaram", 70), ("Rajahmundry", 75), ("Godavari", 60), ("Annavaram", 80)],
    "Annavaram": [("Eluru", 80), ("Godavari", 75)],
    "Kuragallu": [("Vuyyuru", 40), ("Bhimavaram", 30)],
    "Vuyyuru": [("Guntur", 50), ("Kuragallu", 40)]
}

# Define coordinates for each city
coordinates = {
      'Vijayawada': (0, 0),
    'Mangalagiri': (75, 0),
    'Guntur': (75, 140),
    'Tenali': (0, 140),
    'Nidamanuru': (150, 70),
    'Hyderabad': (200, 0),
    'Neerukonda': (250, 70),
    'Kuragallu': (300, 140),
    'Gannavaram': (375, 70),
    'Eluru': (375, 210),
    'Machilipatnam': (300, 280),
    'Repalle': (150, 210),
    'Vuyyuru': (225, 140),
    'Gudivada': (300, 210),
    'Bhimavaram': (375, 140),
    'Tuni': (525, 140),
    'Kakinada': (525, 0),
    'Rajahmundry': (450, 70),
    'Godavari': (450, 280),
    'Annavaram': (525, 280)
}

src = "Vijayawada"
dst = "Mangalagiri"
required_city = "Guntur"

csp_solver = CityPathCSP(weights, coordinates)
path, total_cost = csp_solver.find_path_with_required_city(src, required_city, dst)

x`from constraint import Problem, Domain

class CityDomain(Domain):
    def __init__(self, values):
        self.values = values

    def __iter__(self):
        return iter(self.values)

class CityPathCSP:
    def __init__(self, weights):
        self.weights = weights

    def find_shortest_path(self, src, dst):
        problem = Problem()

        # Get all cities involved in the weights
        all_cities = set()
        for city, neighbors in self.weights.items():
            all_cities.add(city)
            for neighbor, _ in neighbors:
                all_cities.add(neighbor)

        # Add variables to the problem with custom domain class
        for city in all_cities:
            problem.addVariable(city, CityDomain(all_cities))

        # Define constraints to ensure the path starts from src and ends at dst
        def start_end_constraint(*path):
            return path[0] == src and path[-1] == dst

        problem.addConstraint(start_end_constraint)

        # Function to check if the path is valid based on weights
        def path_weight_constraint(*path):
            total_weight = 0
            for i in range(len(path) - 1):
                city1, city2 = path[i], path[i + 1]
                for neighbor, weight in self.weights[city1]:
                    if neighbor == city2:
                        total_weight += weight
                        break
            return total_weight

        problem.addConstraint(path_weight_constraint)

        # Find solutions (paths) satisfying the constraints
        solutions = problem.getSolutions()
        if solutions:
            print("Paths satisfying the constraints:")
            for solution in solutions:
                print(solution)

# Define weights for each edge (using your provided data)
weights = {
    "Vijayawada": [("Mangalagiri", 75), ("Guntur", 140), ("Tenali", 118)],
    "Mangalagiri": [("Vijayawada", 75), ("Nidamanuru", 71), ("Hyderabad", 195)],
    "Guntur": [("Vijayawada", 140), ("Tenali", 40), ("Nidamanuru", 65), ("Neerukonda", 80), ("Vuyyuru", 50)],
    "Tenali": [("Vijayawada", 118), ("Guntur", 40), ("Repalle", 75)],
    "Repalle": [("Tenali", 75), ("Machilipatnam", 80), ("Gudivada", 55)],
    "Machilipatnam": [("Repalle", 80), ("Gannavaram", 75)],
    "Gudivada": [("Repalle", 55), ("Eluru", 20)],
    "Nidamanuru": [("Mangalagiri", 71), ("Hyderabad", 111), ("Guntur", 65)],
    "Hyderabad": [("Mangalagiri", 195), ("Nidamanuru", 111), ("Neerukonda", 99), ("Kakinada", 167), ("Gannavaram", 70)],
    "Neerukonda": [("Hyderabad", 99), ("Bhimavaram", 211)],
    "Kakinada": [("Hyderabad", 167), ("Rajahmundry", 75), ("Godavari", 310), ("Tuni", 138)],
    "Gannavaram": [("Hyderabad", 70), ("Bhimavaram", 138), ("Kakinada", 138), ("Machilipatnam", 75)],
    "Bhimavaram": [("Neerukonda", 211), ("Tuni", 101), ("Rajahmundry", 85), ("Eluru", 70), ("Kuragallu", 30)],
    "Tuni": [("Kakinada", 138), ("Bhimavaram", 101)],
    "Rajahmundry": [("Bhimavaram", 85), ("Kakinada", 75), ("Godavari", 200), ("Eluru", 75)],
    "Godavari": [("Kakinada", 310), ("Rajahmundry", 200), ("Eluru", 60), ("Annavaram", 75)],
    "Eluru": [("Gudivada", 20), ("Bhimavaram", 70), ("Rajahmundry", 75), ("Godavari", 60), ("Annavaram", 80)],
    "Annavaram": [("Eluru", 80), ("Godavari", 75)],
    "Kuragallu": [("Vuyyuru", 40), ("Bhimavaram", 30)],
    "Vuyyuru": [("Guntur", 50), ("Kuragallu", 40)]
    # ... (your weights dictionary)
}

csp_solver = CityPathCSP(weights)

src = "Mangalagiri"
dst = "Vijayawada"

csp_solver.find_shortest_path(src, dst)

import networkx as nx
import matplotlib.pyplot as plt

# Create a graph
G = nx.Graph()

# Add nodes and edges with weights
for city, neighbors in weights.items():
    for neighbor, weight in neighbors:
        G.add_edge(city, neighbor, weight=weight)

# Define node positions based on coordinates
node_positions = {city: coords for city, coords in coordinates.items()}

# Draw the graph
plt.figure(figsize=(12, 8))

# Draw nodes
nx.draw_networkx_nodes(G, pos=node_positions, node_size=300, node_color='skyblue')

# Draw edges
nx.draw_networkx_edges(G, pos=node_positions, width=1.0, alpha=0.5, edge_color='black')

# Draw edge labels (weights)
edge_labels = {(city, neighbor): weight['weight'] for city, neighbor, weight in G.edges(data=True)}
nx.draw_networkx_edge_labels(G, pos=node_positions, edge_labels=edge_labels, font_color='black')

# Draw node labels (city names)
nx.draw_networkx_labels(G, pos=node_positions, font_size=10, font_color='black', font_weight='bold')

plt.title('Graph Visualization of Cities and Weights')
plt.axis('off')
plt.show()

def draw_map(start, end, final_path):
    G = nx.Graph()

    # Add nodes with coordinates
    for city, coord in coordinates.items():
        G.add_node(city, pos=coord)

    # Add edges with weights
    for (city1, city2), weight in weights.items():
        G.add_edge(city1, city2, weight=weight)

    pos = nx.get_node_attributes(G, 'pos')
    labels = nx.get_edge_attributes(G, 'weight')

    # Set a larger figure size for a more spacious plot
    plt.figure(figsize=(12, 8))

    # Draw nodes
    nx.draw(G, pos, with_labels=True, node_size=800, font_size=8, font_color='black', node_color='skyblue', font_weight='bold')

    # Draw edges with weights
    nx.draw_networkx_edges(G, pos, width=1.0, alpha=0.5)
    nx.draw_networkx_edge_labels(G, pos, edge_labels=labels, font_color='red')

    # Highlight start and end nodes


    # Color the nodes in the final_path list in blue
    for i in new_l:
      nx.draw_networkx_nodes(G, pos, nodelist=[i], node_color='grey', node_size=800)

    nx.draw_networkx_nodes(G, pos, nodelist=[start], node_color='green', node_size=800)
    nx.draw_networkx_nodes(G, pos, nodelist=[end], node_color='red', node_size=800)

    plt.title("Map of Cities with A* Path")
    plt.show()

# Example usage
makedict()
final_path = astar(src, dst)  # Assuming astar returns the final_path
draw_map(src, dst, final_path)

import heapq
import math

# Define weights for each edge
weights = {
    ("Vijayawada", "Mangalagiri"): 75,
    ("Vijayawada", "Guntur"): 140,
    ("Vijayawada", "Tenali"): 118,
    ("Tenali","Guntur"): 40,
    ("Tenali","Repalle"): 75,
    ("Repalle","Machilipatnam"): 80,
    ("Repalle","Gudivada"): 55,
    ("Mangalagiri", "Nidamanuru"): 71,
    ("Mangalagiri", "Hyderabad"): 195,
    ("Nidamanuru", "Hyderabad"): 111,
    ("Nidamanuru", "Guntur"): 65,
    ("Hyderabad", "Neerukonda"): 99,
    ("Hyderabad", "Kakinada"): 167,
    ("Guntur", "Neerukonda"): 80,
    ("Guntur", "Vuyyuru"): 50,
    ("Hyderabad", "Gannavaram"): 70,
    ("Neerukonda", "Bhimavaram"): 211,
    ("Kuragallu", "Bhimavaram"): 30,
    ("Gannavaram", "Bhimavaram"): 138,
    ("Gannavaram", "Kakinada"): 138,
    ("Gannavaram", "Machilipatnam"): 75,
    ("Bhimavaram", "Tuni"): 101,
    ("Bhimavaram", "Rajahmundry"): 85,
    ("Kuragallu", "Vuyyuru"): 40,
    ("Tuni", "Kakinada"): 138,
    ("Kakinada", "Rajahmundry"): 75,
    ("Kakinada", "Godavari"): 310,
    ("Rajahmundry", "Godavari"): 200,
    ("Rajahmundry", "Eluru"): 75,
    ("Bhimavaram", "Eluru"): 70,
    ("Gudivada", "Eluru"): 20,
    ("Godavari", "Eluru"): 60,
    ("Annavaram", "Eluru"): 80,
    ("Godavari", "Annavaram"): 75
}

# Define coordinates for each city
coordinates = {
    'Vijayawada': (0, 0),
    'Mangalagiri': (75, 0),
    'Guntur': (75, 140),
    'Tenali': (0, 140),
    'Nidamanuru': (150, 70),
    'Hyderabad': (200, 0),
    'Neerukonda': (250, 70),
    'Kuragallu': (300, 140),
    'Gannavaram': (375, 70),
    'Eluru': (375, 210),
    'Machilipatnam': (300, 280),
    'Repalle': (150, 210),
    'Vuyyuru': (225, 140),
    'Gudivada': (300, 210),
    'Bhimavaram': (375, 140),
    'Tuni': (525, 140),
    'Kakinada': (525, 0),
    'Rajahmundry': (450, 70),
    'Godavari': (450, 280),
    'Annavaram': (525, 280)
}

class PriorityQueue:
    def __init__(self):
        self.cities = []

    def push(self, city, cost):
        heapq.heappush(self.cities, (cost, city))

    def pop(self):
        return heapq.heappop(self.cities)[1]

    def is_empty(self):
        return not bool(self.cities)

    def check(self):
        print(self.cities)

romania = {}

def makedict():
    for edge, dist in weights.items():
        ct1, ct2 = edge
        romania.setdefault(ct1, []).append((ct2, dist))
        romania.setdefault(ct2, []).append((ct1, dist))

def heuristic(node, values):
    return values[node]

def astar(start, end):
    path = {}
    distance = {}
    q = PriorityQueue()

    q.push(start, 0)
    distance[start] = 0
    path[start] = None
    expanded_list = []

    while not q.is_empty():
        current = q.pop()
        expanded_list.append(current)

        if current == end:
            break

        for new, dist in romania[current]:
            g_cost = distance[current] + weights.get((current, new), weights.get((new, current), 0))  # Correct order

            if new not in distance or g_cost < distance[new]:
                distance[new] = g_cost
                f_cost = g_cost + calculate_straight_line_distance(new, end)
                q.push(new, f_cost)
                path[new] = current

    print_output(start, end, path, distance, expanded_list)

new_l=[]
def print_output(start, end, path, distance, expanded_list):
    final_path = []
    i = end

    while path[i] is not None:
        final_path.append(i)
        i = path[i]
    final_path.append(start)
    final_path.reverse()
    new_l.extend(final_path)
    print("A* algorithm program for the given problem")
    print("\t{} => {}".format(start, end))
    print("=======================================================")
    print("A city that may be explored \t\t: " + str(expanded_list))
    print("Number of possible cities\t\t: " + str(len(expanded_list)))
    print("=======================================================")
    print("The city passed with the shortest distance\t: " + str(final_path))
    print("Number of cities passed \t\t\t: " + str(len(final_path)))
    print("Total distance \t\t\t\t\t: " + str(distance[end]))

def euclidean_distance(coord1, coord2):
    return math.sqrt((coord2[0] - coord1[0]) ** 2 + (coord2[1] - coord1[1]) ** 2)

def calculate_straight_line_distance(city1, city2):
    coord1 = coordinates[city1]
    coord2 = coordinates[city2]
    distance = euclidean_distance(coord1, coord2)
    return distance

# Example usage
src = "Hyderabad"
dst = "Godavari"
makedict()
astar(src, dst)

import heapq
import math

# Define weights for each edge
weights = {
    ("Vijayawada", "Mangalagiri"): 75,
    ("Vijayawada", "Guntur"): 140,
    ("Vijayawada", "Tenali"): 118,
    ("Tenali","Guntur"): 40,
    ("Tenali","Repalle"): 75,
    ("Repalle","Machilipatnam"): 80,
    ("Repalle","Gudivada"): 55,
    ("Mangalagiri", "Nidamanuru"): 71,
    ("Mangalagiri", "Hyderabad"): 195,
    ("Nidamanuru", "Hyderabad"): 111,
    ("Nidamanuru", "Guntur"): 65,
    ("Hyderabad", "Neerukonda"): 99,
    ("Hyderabad", "Kakinada"): 167,
    ("Guntur", "Neerukonda"): 80,
    ("Guntur", "Vuyyuru"): 50,
    ("Hyderabad", "Gannavaram"): 70,
    ("Neerukonda", "Bhimavaram"): 211,
    ("Kuragallu", "Bhimavaram"): 30,
    ("Gannavaram", "Bhimavaram"): 138,
    ("Gannavaram", "Kakinada"): 138,
    ("Gannavaram", "Machilipatnam"): 75,
    ("Bhimavaram", "Tuni"): 101,
    ("Bhimavaram", "Rajahmundry"): 85,
    ("Kuragallu", "Vuyyuru"): 40,
    ("Tuni", "Kakinada"): 138,
    ("Kakinada", "Rajahmundry"): 75,
    ("Kakinada", "Godavari"): 310,
    ("Rajahmundry", "Godavari"): 200,
    ("Rajahmundry", "Eluru"): 75,
    ("Bhimavaram", "Eluru"): 70,
    ("Gudivada", "Eluru"): 20,
    ("Godavari", "Eluru"): 60,
    ("Annavaram", "Eluru"): 80,
    ("Godavari", "Annavaram"): 75
}

# Define coordinates for each city
coordinates = {
    'Vijayawada': (0, 0),
    'Mangalagiri': (75, 0),
    'Guntur': (75, 140),
    'Tenali': (0, 140),
    'Nidamanuru': (150, 70),
    'Hyderabad': (200, 0),
    'Neerukonda': (250, 70),
    'Kuragallu': (300, 140),
    'Gannavaram': (375, 70),
    'Eluru': (375, 210),
    'Machilipatnam': (300, 280),
    'Repalle': (150, 210),
    'Vuyyuru': (225, 140),
    'Gudivada': (300, 210),
    'Bhimavaram': (375, 140),
    'Tuni': (525, 140),
    'Kakinada': (525, 0),
    'Rajahmundry': (450, 70),
    'Godavari': (450, 280),
    'Annavaram': (525, 280)
}

class PriorityQueue:
    def __init__(self):
        self.cities = []

    def push(self, city, cost):
        heapq.heappush(self.cities, (cost, city))

    def pop(self):
        return heapq.heappop(self.cities)[1]

    def is_empty(self):
        return not bool(self.cities)

    def check(self):
        print(self.cities)

romania = {}

def makedict():
    for edge, dist in weights.items():
        ct1, ct2 = edge
        romania.setdefault(ct1, []).append((ct2, dist))
        romania.setdefault(ct2, []).append((ct1, dist))

def heuristic(node, values):
    return values[node]

def astar(start, end):
    path = {}
    distance = {}
    q = PriorityQueue()

    q.push(start, 0)
    distance[start] = 0
    path[start] = None
    expanded_list = []

    while not q.is_empty():
        current = q.pop()
        expanded_list.append(current)

        if current == end:
            break

        for new, dist in romania[current]:
            g_cost = distance[current] + weights.get((current, new), weights.get((new, current), 0))  # Correct order

            if new not in distance or g_cost < distance[new]:
                distance[new] = g_cost
                f_cost = g_cost + calculate_straight_line_distance(new, end)
                q.push(new, f_cost)
                path[new] = current

    print_output(start, end, path, distance, expanded_list)

new_l=[]
def print_output(start, end, path, distance, expanded_list):
    final_path = []
    i = end

    while path[i] is not None:
        final_path.append(i)
        i = path[i]
    final_path.append(start)
    final_path.reverse()
    new_l.extend(final_path)
    print("A* algorithm program for the given problem")
    print("\t{} => {}".format(start, end))
    print("=======================================================")
    print("A city that may be explored \t\t: " + str(expanded_list))
    print("Number of possible cities\t\t: " + str(len(expanded_list)))
    print("=======================================================")
    print("The city passed with the shortest distance\t: " + str(final_path))
    print("Number of cities passed \t\t\t: " + str(len(final_path)))
    print("Total distance \t\t\t\t\t: " + str(distance[end]))

def euclidean_distance(coord1, coord2):
    return math.sqrt((coord2[0] - coord1[0]) ** 2 + (coord2[1] - coord1[1]) ** 2)

def calculate_straight_line_distance(city1, city2):
    coord1 = coordinates[city1]
    coord2 = coordinates[city2]
    distance = euclidean_distance(coord1, coord2)
    return distance

# Example usage
src = "Hyderabad"
dst = "Godavari"
makedict()
astar(src, dst)

import heapq
import math

weights = {
    ("Vijayawada", "Mangalagiri"): 75,
    ("Vijayawada", "Guntur"): 140,
    ("Vijayawada", "Tenali"): 118,
    ("Tenali","Guntur"): 40,
    ("Tenali","Repalle"): 75,
    ("Repalle","Machilipatnam"): 80,
    ("Repalle","Gudivada"): 55,
    ("Mangalagiri", "Nidamanuru"): 71,
    ("Mangalagiri", "Hyderabad"): 195,
    ("Nidamanuru", "Hyderabad"): 111,
    ("Nidamanuru", "Guntur"): 65,
    ("Hyderabad", "Neerukonda"): 99,
    ("Hyderabad", "Kakinada"): 167,
    ("Guntur", "Neerukonda"): 80,
    ("Guntur", "Vuyyuru"): 50,
    ("Hyderabad", "Gannavaram"): 70,
    ("Neerukonda", "Bhimavaram"): 211,
    ("Kuragallu", "Bhimavaram"): 30,
    ("Gannavaram", "Bhimavaram"): 138,
    ("Gannavaram", "Kakinada"): 138,
    ("Gannavaram", "Machilipatnam"): 75,
    ("Bhimavaram", "Tuni"): 101,
    ("Bhimavaram", "Rajahmundry"): 85,
    ("Kuragallu", "Vuyyuru"): 40,
    ("Tuni", "Kakinada"): 138,
    ("Kakinada", "Rajahmundry"): 75,
    ("Kakinada", "Godavari"): 310,
    ("Rajahmundry", "Godavari"): 200,
    ("Rajahmundry", "Eluru"): 75,
    ("Bhimavaram", "Eluru"): 70,
    ("Gudivada", "Eluru"): 20,
    ("Godavari", "Eluru"): 60,
    ("Annavaram", "Eluru"): 80,
    ("Godavari", "Annavaram"): 75
}

coordinates = {
        'Vijayawada': (0, 0),
    'Mangalagiri': (75, 0),
    'Guntur': (75, 140),
    'Tenali': (0, 140),
    'Nidamanuru': (150, 70),
    'Hyderabad': (200, 0),
    'Neerukonda': (250, 70),
    'Kuragallu': (300, 140),
    'Gannavaram': (375, 70),
    'Eluru': (375, 210),
    'Machilipatnam': (300, 280),
    'Repalle': (150, 210),
    'Vuyyuru': (225, 140),
    'Gudivada': (300, 210),
    'Bhimavaram': (375, 140),
    'Tuni': (525, 140),
    'Kakinada': (525, 0),
    'Rajahmundry': (450, 70),
    'Godavari': (450, 280),
    'Annavaram': (525, 280)
}

class PriorityQueue:
    def __init__(self):
        self.cities = []

    def push(self, city, cost):
        heapq.heappush(self.cities, (cost, city))

    def pop(self):
        return heapq.heappop(self.cities)[1]

    def is_empty(self):
        return not bool(self.cities)

romania = {}

# ... (Previous code remains the same)

def makedict_with_constraints():
    for edge, dist in weights.items():
        ct1, ct2 = edge
        romania.setdefault(ct1, []).append((ct2, dist))
        romania.setdefault(ct2, []).append((ct1, dist))

        # Define constraints for neighboring cities
        romania.setdefault(ct1 + '_constraints', {}).setdefault(ct2, []).append(lambda coord1, coord2, dist=dist: math.sqrt((coord2[0] - coord1[0]) ** 2 + (coord2[1] - coord1[1]) ** 2) <= dist)
        romania.setdefault(ct2 + '_constraints', {}).setdefault(ct1, []).append(lambda coord1, coord2, dist=dist: math.sqrt((coord2[0] - coord1[0]) ** 2 + (coord2[1] - coord1[1]) ** 2) <= dist)

# ... (Remaining code remains the same)


def heuristic(node, values):
    return values[node]

def astar_with_constraints(start, end):
    path = {}
    distance = {}
    q = PriorityQueue()

    q.push(start, 0)
    distance[start] = 0
    path[start] = None
    expanded_list = []

    while not q.is_empty():
        current = q.pop()
        expanded_list.append(current)

        if current == end:
            break

        for new, dist in romania[current]:
            # Check constraints
            if current + '_constraints' in romania and new in romania[current + '_constraints']:
                constraints = romania[current + '_constraints'][new]
                if not all(constraint(coordinates[current], coordinates[new], dist) for constraint in constraints):
                    continue

            g_cost = distance[current] + weights.get((current, new), weights.get((new, current), 0))  # Correct order

            if new not in distance or g_cost < distance[new]:
                distance[new] = g_cost
                f_cost = g_cost + calculate_straight_line_distance(new, end)
                q.push(new, f_cost)
                path[new] = current

    print_output(start, end, path, distance, expanded_list)

def print_output(start, end, path, distance, expanded_list):
    final_path = []
    i = end

    while path[i] is not None:
        final_path.append(i)
        i = path[i]
    final_path.append(start)
    final_path.reverse()

    print("A* algorithm program for the given problem")
    print("\t{} => {}".format(start, end))
    print("=======================================================")
    print("A city that may be explored \t\t: " + str(expanded_list))
    print("Number of possible cities\t\t: " + str(len(expanded_list)))
    print("=======================================================")
    print("The city passed with the shortest distance\t: " + str(final_path))
    print("Number of cities passed \t\t\t: " + str(len(final_path)))
    print("Total distance \t\t\t\t\t: " + str(distance[end]))

def euclidean_distance(coord1, coord2):
    return math.sqrt((coord2[0] - coord1[0]) ** 2 + (coord2[1] - coord1[1]) ** 2)

def calculate_straight_line_distance(city1, city2):
    coord1 = coordinates[city1]
    coord2 = coordinates[city2]
    distance = euclidean_distance(coord1, coord2)
    return distance

# Example usage with constraints
src = "Hyderabad"
dst = "Repalle"
makedict_with_constraints()
astar_with_constraints(src, dst)

import heapq
import math

# Define weights for each edge
weights = {
    ("Vijayawada", "Mangalagiri"): 75,
    ("Vijayawada", "Guntur"): 140,
    ("Vijayawada", "Tenali"): 118,
    ("Tenali","Guntur"): 40,
    ("Tenali","Repalle"): 75,
    ("Repalle","Machilipatnam"): 80,
    ("Repalle","Gudivada"): 55,
    ("Mangalagiri", "Nidamanuru"): 71,
    ("Mangalagiri", "Hyderabad"): 195,
    ("Nidamanuru", "Hyderabad"): 111,
    ("Nidamanuru", "Guntur"): 65,
    ("Hyderabad", "Neerukonda"): 99,
    ("Hyderabad", "Kakinada"): 167,
    ("Guntur", "Neerukonda"): 80,
    ("Guntur", "Vuyyuru"): 50,
    ("Hyderabad", "Gannavaram"): 70,
    ("Neerukonda", "Bhimavaram"): 211,
    ("Kuragallu", "Bhimavaram"): 30,
    ("Gannavaram", "Bhimavaram"): 138,
    ("Gannavaram", "Kakinada"): 138,
    ("Gannavaram", "Machilipatnam"): 75,
    ("Bhimavaram", "Tuni"): 101,
    ("Bhimavaram", "Rajahmundry"): 85,
    ("Kuragallu", "Vuyyuru"): 40,
    ("Tuni", "Kakinada"): 138,
    ("Kakinada", "Rajahmundry"): 75,
    ("Kakinada", "Godavari"): 310,
    ("Rajahmundry", "Godavari"): 200,
    ("Rajahmundry", "Eluru"): 75,
    ("Bhimavaram", "Eluru"): 70,
    ("Gudivada", "Eluru"): 20,
    ("Godavari", "Eluru"): 60,
    ("Annavaram", "Eluru"): 80,
    ("Godavari", "Annavaram"): 75
}

# Define coordinates for each city
coordinates = {
    'Vijayawada': (0, 0),
    'Mangalagiri': (75, 0),
    'Guntur': (75, 140),
    'Tenali': (0, 140),
    'Nidamanuru': (150, 70),
    'Hyderabad': (200, 0),
    'Neerukonda': (250, 70),
    'Kuragallu': (300, 140),
    'Gannavaram': (375, 70),
    'Eluru': (375, 210),
    'Machilipatnam': (300, 280),
    'Repalle': (150, 210),
    'Vuyyuru': (225, 140),
    'Gudivada': (300, 210),
    'Bhimavaram': (375, 140),
    'Tuni': (525, 140),
    'Kakinada': (525, 0),
    'Rajahmundry': (450, 70),
    'Godavari': (450, 280),
    'Annavaram': (525, 280)
}

class PriorityQueue:
    def __init__(self):
        self.cities = []

    def push(self, city, cost):
        heapq.heappush(self.cities, (cost, city))

    def pop(self):
        return heapq.heappop(self.cities)[1]

    def is_empty(self):
        return not bool(self.cities)

    def check(self):
        print(self.cities)

romania = {}

def makedict():
    for edge, dist in weights.items():
        ct1, ct2 = edge
        romania.setdefault(ct1, []).append((ct2, dist))
        romania.setdefault(ct2, []).append((ct1, dist))

def heuristic(node, values):
    return values[node]

def astar_with_constraint(start, end, stop_city):
    path = {}
    distance = {}
    q = PriorityQueue()

    q.push(start, 0)
    distance[start] = 0
    path[start] = None
    expanded_list = []

    while not q.is_empty():
        current = q.pop()
        expanded_list.append(current)

        if current == end:
            break

        for new, dist in romania[current]:
            g_cost = distance[current] + weights.get((current, new), weights.get((new, current), 0))

            if new not in distance or g_cost < distance[new]:
                distance[new] = g_cost
                f_cost = g_cost + calculate_straight_line_distance(new, end)
                q.push(new, f_cost)
                path[new] = current

    # Check if the stop city is in the final path
    if stop_city not in path:
        print(f"Path doesn't include {stop_city}.")
        return

    # Reconstruct the final path considering the stop city constraint
    final_path = []
    i = end
    while path[i] is not None:
        final_path.append(i)
        if i == stop_city:
            break
        i = path[i]
    final_path.append(start)
    final_path.reverse()
    new_l.extend(final_path)
    print_output(start, end, path, distance, expanded_list)


new_l=[]
def print_output(start, end, path, distance, expanded_list):
    final_path = []
    i = end

    while path[i] is not None:
        final_path.append(i)
        i = path[i]
    final_path.append(start)
    final_path.reverse()
    new_l.extend(final_path)
    print("A* algorithm program for the given problem")
    print("\t{} => {}".format(start, end))
    print("=======================================================")
    print("A city that may be explored \t\t: " + str(expanded_list))
    print("Number of possible cities\t\t: " + str(len(expanded_list)))
    print("=======================================================")
    print("The city passed with the shortest distance\t: " + str(final_path))
    print("Number of cities passed \t\t\t: " + str(len(final_path)))
    print("Total distance \t\t\t\t\t: " + str(distance[end]))

def euclidean_distance(coord1, coord2):
    return math.sqrt((coord2[0] - coord1[0]) ** 2 + (coord2[1] - coord1[1]) ** 2)

def calculate_straight_line_distance(city1, city2):
    coord1 = coordinates[city1]
    coord2 = coordinates[city2]
    distance = euclidean_distance(coord1, coord2)
    return distance

def csp_path_with_stop(src, dst, stop_city):
    path_variables = list(coordinates.keys())  # Variables: Cities in the path
    path_domains = {city: list(range(len(coordinates))) for city in path_variables}  # Domains: Indices in the path

    def check_constraint(path):
        return stop_city in path and path.index(stop_city) < len(path) - 1

    def backtrack_search(path):
        if len(path) == len(path_variables):
            return path

        for city in path_variables:
            if city not in path:
                new_path = path + [city]
                if check_constraint(new_path):
                    result = backtrack_search(new_path)
                    if result:
                        return result
        return None

    result_path = backtrack_search([src])

    if result_path:
        print("Path found with stop city:", result_path)
    else:
        print("No valid path with the given constraints.")

# Example usage
src = "Hyderabad"
dst = "Godavari"
stop_city = "Guntur"  # Change this to the city you want to ensure is included in the path
csp_path_with_stop(src, dst, stop_city)

# Example usage
src = "Hyderabad"
dst = "Godavari"
stop_city = "Mangalagiri"  # Change this to the city you want to ensure is included in the path
makedict()
astar_with_constraint(src, dst, stop_city)

src = "Hyderabad"
dst = "Godavari"

import heapq
import math

class PriorityQueue:
    def __init__(self):
        self.cities = []

    def push(self, city, cost):
        heapq.heappush(self.cities, (cost, city))

    def pop(self):
        return heapq.heappop(self.cities)[1]

    def is_empty(self):
        return not bool(self.cities)

# Define weights for each edge
weights = {
    ("Vijayawada", "Mangalagiri"): 75,
    ("Vijayawada", "Guntur"): 140,
    ("Vijayawada", "Tenali"): 118,
    ("Tenali","Guntur"): 40,
    ("Tenali","Repalle"): 75,
    ("Repalle","Machilipatnam"): 80,
    ("Repalle","Gudivada"): 55,
    ("Mangalagiri", "Nidamanuru"): 71,
    ("Mangalagiri", "Hyderabad"): 195,
    ("Nidamanuru", "Hyderabad"): 111,
    ("Nidamanuru", "Guntur"): 65,
    ("Hyderabad", "Neerukonda"): 99,
    ("Hyderabad", "Kakinada"): 167,
    ("Guntur", "Neerukonda"): 80,
    ("Guntur", "Vuyyuru"): 50,
    ("Hyderabad", "Gannavaram"): 70,
    ("Neerukonda", "Bhimavaram"): 211,
    ("Kuragallu", "Bhimavaram"): 30,
    ("Gannavaram", "Bhimavaram"): 138,
    ("Gannavaram", "Kakinada"): 138,
    ("Gannavaram", "Machilipatnam"): 75,
    ("Bhimavaram", "Tuni"): 101,
    ("Bhimavaram", "Rajahmundry"): 85,
    ("Kuragallu", "Vuyyuru"): 40,
    ("Tuni", "Kakinada"): 138,
    ("Kakinada", "Rajahmundry"): 75,
    ("Kakinada", "Godavari"): 310,
    ("Rajahmundry", "Godavari"): 200,
    ("Rajahmundry", "Eluru"): 75,
    ("Bhimavaram", "Eluru"): 70,
    ("Gudivada", "Eluru"): 20,
    ("Godavari", "Eluru"): 60,
    ("Annavaram", "Eluru"): 80,
    ("Godavari", "Annavaram"): 75
}

# Define coordinates for each city
coordinates = {
    'Vijayawada': (0, 0),
    'Mangalagiri': (75, 0),
    'Guntur': (75, 140),
    'Tenali': (0, 140),
    'Nidamanuru': (150, 70),
    'Hyderabad': (200, 0),
    'Neerukonda': (250, 70),
    'Kuragallu': (300, 140),
    'Gannavaram': (375, 70),
    'Eluru': (375, 210),
    'Machilipatnam': (300, 280),
    'Repalle': (150, 210),
    'Vuyyuru': (225, 140),
    'Gudivada': (300, 210),
    'Bhimavaram': (375, 140),
    'Tuni': (525, 140),
    'Kakinada': (525, 0),
    'Rajahmundry': (450, 70),
    'Godavari': (450, 280),
    'Annavaram': (525, 280)
}

# Define petrol constraints for each city (assuming a petrol tank size of 100)
petrol_constraints = {
    'Hyderabad': 100,
    'Neerukonda': 50,
    'Guntur': 80,
    'Kakinada': 30,
    'Rajahmundry': 70,
    'Godavari': 20
}

# Define petrol consumption rate (units per distance traveled)
petrol_consumption_rate = 0.01

romania = {}

def makedict():
    for edge, dist in weights.items():
        ct1, ct2 = edge
        romania.setdefault(ct1, []).append((ct2, dist))
        romania.setdefault(ct2, []).append((ct1, dist))

def heuristic(node, values):
    return values[node]

def astar_with_petrol_consumption(start, end, initial_petrol):
    path = {}
    distance = {}
    petrol = {}
    q = PriorityQueue()

    q.push((start, initial_petrol), 0)
    distance[start, initial_petrol] = 0
    path[start, initial_petrol] = None
    expanded_list = []

    while not q.is_empty():
        current, current_petrol = q.pop()
        expanded_list.append(current)

        if current == end:
            break

        for new, dist in romania[current]:
            # Calculate the petrol needed for the current edge
            petrol_needed = weights.get((current, new), weights.get((new, current), 0))

            # Calculate the petrol consumed during travel
            petrol_consumed = petrol_consumption_rate * petrol_needed

            # Check if the petrol tank is sufficient
            if current_petrol >= petrol_consumed:
                new_petrol = current_petrol - petrol_consumed

                # Check if there's a petrol station at the current city
                if new in petrol_constraints and new_petrol <= 30:  # Fill up petrol tank if below 30 units
                    new_petrol = min(100, new_petrol + petrol_constraints[new])  # Refill at petrol station

                g_cost = distance[current, current_petrol] + petrol_consumed  # Update g_cost

                if (new, new_petrol) not in distance or g_cost < distance[new, new_petrol]:
                    distance[new, new_petrol] = g_cost
                    f_cost = g_cost + calculate_straight_line_distance(new, end)
                    q.push((new, new_petrol), f_cost)
                    path[new, new_petrol] = (current, current_petrol)

    print_output(start, end, path, distance, expanded_list, initial_petrol)

def print_output(start, end, path, distance, expanded_list, initial_petrol):
    final_path = []
    i, petrol = end, 0

    while path.get((i, petrol)) is not None:
        final_path.append((i, petrol))
        i, petrol = path[i, petrol]

    final_path.reverse()

    print("A* algorithm program for the given problem with petrol consumption and filling up constraints")
    print("\t{} => {}".format(start, end))
    print("=======================================================")
    print("A city that may be explored \t\t: " + str(expanded_list))
    print("Number of possible cities\t\t: " + str(len(expanded_list)))
    print("=======================================================")
    print("The city passed with the shortest distance\t: " + str([city for city, _ in final_path]))
    print("Petrol level at each city\t\t\t: " + str([petrol for _, petrol in final_path]))
    print("Number of cities passed \t\t\t: " + str(len(final_path)))
    # print("Total distance \t\t\t\t\t: " + str(distance[end]))
    print(distance)
    print("Initial petrol level \t\t\t: " + str(initial_petrol))

# Example usage with initial petrol level of 80
src = "Hyderabad"
dst = "Godavari"
makedict()
astar_with_petrol_consumption(src, dst, 80)

